// Simple operations on a file: read, write, append.

"use strict";

var fs = require('fs');
var Q = require('q');
var mkdirp = require('mkdirp');
var pathUtil = require('path');

// Temporary file extensions used for "safe" file overwriting.
var newExt = ".__new__";

function isValidReturnType(type) {
    return ['utf8', 'buf', 'json', 'jsonWithDates'].indexOf(type) !== -1;
}

// Matches strings generated by Date.toJSON() which is called to serialize date to JSON.
function jsonDateParser(key, value) {
    var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
    if (typeof value === 'string') {
        if (reISO.exec(value)) {
            return new Date(value);
        }
    }
    return value;
};

function normalizeDataToWrite(data, options) {
    // if this crazy "if" is true we are sure the passed thing is simple object
    if (Buffer.isBuffer(data) === false &&
            typeof data === 'object' &&
            data != null) {
        var indent = options.jsonIndent;
        if (typeof indent !== 'number') {
            indent = 2;
        }
        data = JSON.stringify(data, null, indent);
    }

    return data;
}

function normalizeOptions(options) {
    return options || {};
}

function makeNicerJsonParsingError(path, err) {
    var nicerError = new Error('JSON parsing failed while reading '
        + path + ' [' + err + ']');
    nicerError.originalError = err;
    return nicerError;
}

//---------------------------------------------------------
// SYNC
//---------------------------------------------------------

function read(path, returnAs, options) {
    options = options || {};
    options.returnAs = returnAs;

    if (!isValidReturnType(options.returnAs)) {
        options.returnAs = 'utf8';
    }

    var encoding = 'utf8';
    if (options.returnAs === 'buf') {
        encoding = null;
    }

    var data;
    try {
        data = fs.readFileSync(path, { encoding: encoding });
    } catch (err) {
        if (err.code === 'ENOENT') {
            // if file doesn't exist just return null, no need to raise error
            data = null;
        } else {
            // otherwise rethrow event
            throw err;
        }
    }

    try {
        if (options.returnAs === 'json') {
            data = JSON.parse(data);
        } else if (options.returnAs === 'jsonWithDates') {
            data = JSON.parse(data, jsonDateParser);
        }
    } catch (err) {
        throw makeNicerJsonParsingError(path, err);
    }

    return data;
}

// Like normal fs.writeFileSync, but with mkdirp.
function writeFileSync(path, data, options) {
    try {
        fs.writeFileSync(path, data, options);
    } catch (err) {
        if (err.code === 'ENOENT') {
            // Means parent directory doesn't exist, so create it and try again.
            mkdirp.sync(pathUtil.dirname(path));
            fs.writeFileSync(path, data, options);
        } else {
            throw err;
        }
    }
}

// Writing the file in "safe" mode.
function writeSafeSync(path, data, options) {
    // we are assuming there is file on given path, and we don't want
    // to touch it until we are sure our data has been saved correctly,
    // so write the data into NEW file
    writeFileSync(path + newExt, data, options);

    // next rename NEW file to real path
    fs.renameSync(path + newExt, path);
}

function write(path, data, options) {
    options = normalizeOptions(options);
    data = normalizeDataToWrite(data, options);

    if (options.atomic === true) {
        writeSafeSync(path, data, { mode: options.mode })
    } else {
        writeFileSync(path, data, { mode: options.mode });
    }
}

function append(path, data, options) {
    try {
        fs.appendFileSync(path, data, options);
    } catch (err) {
        if (err.code === 'ENOENT') {
            // parent directory doesn't exist, so just create it and write the file
            writeFileSync(path, data, options);
        } else {
            throw err;
        }
    }
}

//---------------------------------------------------------
// ASYNC
//---------------------------------------------------------

var qUnlink = Q.denodeify(fs.unlink);
var qReadFile = Q.denodeify(fs.readFile);
var qRename = Q.denodeify(fs.rename);
var qWriteFile = Q.denodeify(fs.writeFile);
var qAppendFile = Q.denodeify(fs.appendFile);
var qMkdirp = Q.denodeify(mkdirp);

function readAsync(path, returnAs, options) {
    var deferred = Q.defer();
    options = options || {};
    options.returnAs = returnAs;

    if (!isValidReturnType(options.returnAs)) {
        options.returnAs = 'utf8';
    }

    var encoding = 'utf8';
    if (options.returnAs === 'buf') {
        encoding = null;
    }

    qReadFile(path, { encoding: encoding })
    .then(dataReady, function (err) {
        if (err.code === 'ENOENT') {
            // if file doesn't exist just return null, no need to raise error
            deferred.resolve(null);
        } else {
            // otherwise rethrow event
            deferred.reject(err);
        }
    });

    function dataReady(data) {
        // Make final parsing of data before returning.
        try {
            if (options.returnAs === 'json') {
                data = JSON.parse(data);
            } else if (options.returnAs === 'jsonWithDates') {
                data = JSON.parse(data, jsonDateParser);
            }
            deferred.resolve(data);
        } catch (err) {
            deferred.reject(makeNicerJsonParsingError(path, err));
        }
    }

    return deferred.promise;
}

// Like normal fs.writeFile, but with mkdirp.
var writeFileAsync = function (path, data, options) {
    var deferred = Q.defer();

    qWriteFile(path, data, options)
    .then(deferred.resolve)
    .catch(function (err) {
        // First attempt to write a file ended with error.
        // Check if this is not due to nonexistent parent directory.
        if (err.code === 'ENOENT') {
            // Parent directory doesn't exist, so create it and try again.
            qMkdirp(pathUtil.dirname(path))
            .then(function () {
                return qWriteFile(path, data, options);
            })
            .then(deferred.resolve, deferred.reject);
        } else {
            // Nope, some other error, throw it.
            deferred.reject(err);
        }
    });

    return deferred.promise;
};

// Writing the file in "safe" mode.
function writeSafeAsync(path, data, options) {
    var deferred = Q.defer();

    // we are assuming there is file on given path, and we don't want
    // to touch it until we are sure our data has been saved correctly,
    // so write the data into NEW file
    writeFileAsync(path + newExt, data, options)
    .then(function () {
        // next rename NEW file to real path
        qRename(path + newExt, path)
        .then(deferred.resolve, deferred.reject);
    });

    return deferred.promise;
}

function writeAsync(path, data, options) {
    var deferred = Q.defer();

    options = normalizeOptions(options);
    data = normalizeDataToWrite(data, options);

    if (options.atomic === true) {
        writeSafeAsync(path, data, { mode: options.mode })
        .then(deferred.resolve, deferred.reject);
    } else {
        writeFileAsync(path, data, { mode: options.mode })
        .then(deferred.resolve, deferred.reject);
    }

    return deferred.promise;
}

function appendAsync(path, data, options) {
    var deferred = Q.defer();

    qAppendFile(path, data, options)
    .then(deferred.resolve, function (err) {

        if (err.code === 'ENOENT') {
            // if parent directory doesn't exist create it
            mkdirp(pathUtil.dirname(path), function (err) {
                if (err) {
                    // something went wrong with directory creation
                    deferred.reject(err);
                } else {
                    // retry
                    appendAsync(path, data, options)
                    .then(deferred.resolve, deferred.reject);
                }
            });
        } else {
            deferred.reject(err);
        }

    });

    return deferred.promise;
}

//---------------------------------------------------------
// API
//---------------------------------------------------------

module.exports.read = read;
module.exports.write = write;
module.exports.append = append;

module.exports.readAsync = readAsync;
module.exports.writeAsync = writeAsync;
module.exports.appendAsync = appendAsync;
